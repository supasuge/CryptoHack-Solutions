

# This file was *autogenerated* from the file scalar_multiplcation.sage
from sage.all_cmdline import *   # import sage library

_sage_const_9739 = Integer(9739); _sage_const_497 = Integer(497); _sage_const_1768 = Integer(1768); _sage_const_2339 = Integer(2339); _sage_const_2213 = Integer(2213); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_7863 = Integer(7863); _sage_const_5323 = Integer(5323); _sage_const_5438 = Integer(5438); _sage_const_1337 = Integer(1337); _sage_const_1089 = Integer(1089); _sage_const_6931 = Integer(6931)# Define the finite field
p = _sage_const_9739 
F = GF(p)

# Define the elliptic curve
E = EllipticCurve(F, [_sage_const_497 , _sage_const_1768 ])

# Define the point P
P = E(_sage_const_2339 , _sage_const_2213 )

# Implement the Double-and-Add algorithm
def double_and_add(P, n):
    Q = P
    R = E(_sage_const_0 )  # Point at infinity (identity element)
    while n > _sage_const_0 :
        if n % _sage_const_2  == _sage_const_1 :
            R = R + Q
        Q = _sage_const_2  * Q
        n = n // _sage_const_2 
    return R

# Calculate [7863]P
n = _sage_const_7863 
Q = double_and_add(P, n)

print(f"Q = [7863]P = {Q}")

# Verify that Q is on the curve
assert Q in E, "Q is not on the curve"

# Format the answer
x, y = Q.xy()
answer = f"crypto{{{x}.{y}}}"
print(f"Answer: {answer}")

# Additional verification
X = E(_sage_const_5323 , _sage_const_5438 )
assert double_and_add(X, _sage_const_1337 ) == E(_sage_const_1089 , _sage_const_6931 ), "Verification failed"

